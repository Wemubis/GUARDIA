# coding: utf-8

import sys

def hamming_distance(y1, y2):

	if isinstance(y1, str):
		y1 = y1.encode('utf-8')
	if isinstance(y2, str):
		y2 = y2.encode('utf-8')

	assert len(y1) == len(y2)

	# XOR corresponding bytes and count differing bits (only the 1s)
	differing_bits = sum(bin(byte1 ^ byte2).count('1') for byte1, byte2 in zip(y1, y2))

	return differing_bits

def norm_hamming_distance(y, key_size):
	part1 = y[:key_size]
	part2 = y[key_size:key_size * 2]
	
	distance = hamming_distance(part1, part2)
	
	return distance / key_size

def guess_keysize(y, key_size_min = 2, key_size_max = 40):
	key_size_scores = []
	
	for key_size in range(key_size_min, key_size_max):
		norm_distance = norm_hamming_distance(y, key_size)
		key_size_scores.append((key_size, norm_distance))
	
	key_size_scores.sort()
	probable_key_size = [score[0] for score in key_size_scores[:3]]
		
	return probable_key_size

def break_cipher_text(y, probable_key_size):
	for key_size in probable_key_size:
		block = [y[i:i+key_size] for i in range(0, len(y), key_size)]
	return block

def transpose_blocks(blocks, keysize):
	transposed = []
	# The goal is to take the input i of each block and add them in a same block
	for i in keysize:
		transposed_block = bytearray()
		for block in blocks:
			if i < len(block):
				transposed_block.append(block[i])
		transposed.append(bytes(transposed_block))
	return transposed




def main():
	with open("xor_6.txt", "r") as f:
		b64_content = f.read().strip()
	
	key_sizes = guess_keysize(b64_content)
	blocks = break_cipher_text(b64_content, key_sizes)
	trans_blocks = transpose_blocks(blocks, key_sizes)
	print(trans_blocks)
	
if __name__ == "__main__":
	main()

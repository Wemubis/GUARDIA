from flask import Flask, render_template, request, jsonify, session, redirect, url_for
import sqlite3
from Crypto.Cipher import AES
from Crypto.Hash import SHA1
from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_v1_5
from Crypto.Random import get_random_bytes
from base64 import b64encode, b64decode
import base64

app = Flask(__name__)
app.secret_key = 'weak_secret_key'

# Path to the database file
DB_FILE = "votes.db"

# Initialisation de la base de données
def init_db():
	conn = sqlite3.connect('votes.db')
	cursor = conn.cursor()
	cursor.execute('''CREATE TABLE IF NOT EXISTS votes (
						id INTEGER PRIMARY KEY AUTOINCREMENT,
						username TEXT NOT NULL,
						encrypted_vote TEXT NOT NULL,
						encrypted_key TEXT NOT NULL)''')
	cursor.execute('''CREATE TABLE IF NOT EXISTS users (
						username TEXT PRIMARY KEY,
						password TEXT NOT NULL,
						is_admin INTEGER DEFAULT 0,
						private_key_hash TEXT)''')
	conn.commit()
	
	# Génération de la clé RSA de 1024 bits
	private_key = RSA.generate(1024)

	# Create default admin account if it doesn't exist
	cursor.execute("SELECT * FROM users WHERE username = ?", ('admin',))
	if not cursor.fetchone():
		sha1 = SHA1.new()
		sha1.update('admin'.encode())
		hashed_password = sha1.hexdigest()

		cursor.execute("INSERT INTO users (username, password, is_admin, private_key_hash) VALUES (?, ?, ?, ?)",
					('admin', hashed_password, 1, base64.b64encode(private_key.export_key()).decode()))
		conn.commit()
		
	conn.close()

# Retrieve the RSA private key
def get_private_key():
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()
    cursor.execute("SELECT private_key_hash FROM users WHERE username == 'admin'")
    result = cursor.fetchone()
    conn.close()

    if result:
        private_key_data = b64decode(result[0])
        return RSA.import_key(private_key_data)
    else:
        raise ValueError("Private key not found in the database.")

@app.route('/')
def login_page():
    return render_template('login.html')

@app.route('/login', methods=['POST'])
def login():
    username = request.form.get('username')
    password = request.form.get('password')

    # Hash le mot de passe avec SHA-1
    sha1 = SHA1.new()
    sha1.update(password.encode())
    hashed_password = sha1.hexdigest()

    conn = sqlite3.connect('votes.db')
    cursor = conn.cursor()
    cursor.execute(f"SELECT username, password, is_admin FROM users WHERE username = '{username}' AND password = '{hashed_password}'")
    user = cursor.fetchone()  # Vulnérabilité SQLi intentionnelle
    conn.close()

    if user:
        session['username'] = user[0]
        session['is_admin'] = bool(user[2])
        if session['is_admin']:
            return redirect(url_for('admin_page'))
        return redirect(url_for('vote_page'))
    else:
        return render_template('login.html', error="Nom d'utilisateur ou mot de passe incorrect")

@app.route('/register', methods=['GET', 'POST'])
def register():
    if request.method == 'POST':
        username = request.form.get('username')
        password = request.form.get('password')

        # Hash le mot de passe avec SHA-1
        sha1 = SHA1.new()
        sha1.update(password.encode())
        hashed_password = sha1.hexdigest()

        conn = sqlite3.connect('votes.db')
        cursor = conn.cursor()
        cursor.execute(f"INSERT INTO users (username, password) VALUES ('{username}', '{hashed_password}')")  # Vulnérabilité SQLi
        conn.commit()
        conn.close()
        return redirect(url_for('login_page'))

    return render_template('register.html')

@app.route('/vote_page')
def vote_page():
    if 'username' not in session:
        return redirect(url_for('login_page'))
    return render_template('vote.html')

@app.route('/vote', methods=['POST'])
def vote():
    if 'username' not in session:
        return jsonify({"message": "Non autorisé. Veuillez vous connecter."}), 403

    username = session['username']
    # Vérifiez si l'utilisateur a déjà voté
    conn = sqlite3.connect('votes.db')
    cursor = conn.cursor()
    cursor.execute("SELECT * FROM votes WHERE username = ?", (username,))
    if cursor.fetchone():
        conn.close()
        return jsonify({"message": "Vous avez déjà voté."}), 400
    
    candidate = request.json.get('candidate')

    if not candidate:
        return jsonify({"message": "Candidat invalide."}), 400

    # Générer une clé AES
    aes_key = b'5:)\xe4\n4\x07\x1d\x9c(\xe0\xdcX\xe3\x15\xe1'

    # Chiffrer le vote avec AES en mode ECB
    cipher = AES.new(aes_key, AES.MODE_ECB)
    padded_candidate = candidate.ljust(16).encode()  # Padding manuel à 16 octets
    encrypted_vote = cipher.encrypt(padded_candidate)

    # Chiffrer la clé AES avec RSA-1024
    private_key = get_private_key()
    rsa_cipher = PKCS1_v1_5.new(private_key.publickey())
    encrypted_key = rsa_cipher.encrypt(aes_key)

    # Stocker les données dans la base de données
    conn = sqlite3.connect('votes.db')
    cursor = conn.cursor()
    cursor.execute("""
        INSERT INTO votes (username, encrypted_vote, encrypted_key)
        VALUES (?, ?, ?)""",
        (
            username,
            b64encode(encrypted_vote).decode(),
            b64encode(encrypted_key).decode()
        )
    )
    conn.commit()
    conn.close()

    return jsonify({"message": "Vote enregistré avec succès !"}), 200

@app.route('/admin')
def admin_page():
    if 'username' not in session or not session.get('is_admin', False):
        return redirect(url_for('login_page'))

    conn = sqlite3.connect('votes.db')
    cursor = conn.cursor()
    cursor.execute("SELECT encrypted_vote, encrypted_key FROM votes")
    results = cursor.fetchall()
    conn.close()
    
    private_key = get_private_key()
    decrypted_results = []
    vote_counts = {}

    for row in results:
        try:
            encrypted_vote = b64decode(row[0])
            encrypted_key = b64decode(row[1])

            # Déchiffrer la clé AES avec RSA-1024
            rsa_cipher = PKCS1_v1_5.new(private_key)
            aes_key = rsa_cipher.decrypt(encrypted_key, None)

            # Déchiffrer le vote avec AES en mode ECB
            cipher = AES.new(aes_key, AES.MODE_ECB)
            decrypted_vote = cipher.decrypt(encrypted_vote).decode('utf-8').strip()

            # Compter les votes
            if decrypted_vote in vote_counts:
                vote_counts[decrypted_vote] += 1
            else:
                vote_counts[decrypted_vote] = 1
        except Exception as e:
            print(f"Erreur lors du déchiffrement : {e}")

    # Construire les résultats sous forme de liste
    decrypted_results = [(candidate, count) for candidate, count in vote_counts.items()]

    return render_template('admin.html', results=decrypted_results)

@app.route('/logout')
def logout():
    session.clear()
    return redirect(url_for('login_page'))

if __name__ == '__main__':
    init_db()
    app.run(debug=True)

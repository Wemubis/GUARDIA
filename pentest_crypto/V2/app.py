from flask import Flask, render_template, request, jsonify, session, redirect, url_for
import sqlite3
from werkzeug.security import generate_password_hash, check_password_hash
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.primitives.asymmetric import rsa, padding
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.hmac import HMAC
import os
import base64
from markupsafe import escape
import logging
from logging.handlers import RotatingFileHandler

app = Flask(__name__)
app.secret_key = 'macron_explosion'

# Set up audit logging
log_handler = RotatingFileHandler("audit.log", maxBytes=1000000, backupCount=5)
log_handler.setFormatter(logging.Formatter("%(asctime)s - %(levelname)s - %(message)s"))
audit_logger = logging.getLogger("audit")
audit_logger.setLevel(logging.INFO)
audit_logger.addHandler(log_handler)

# Initialize database
def init_db():
    conn = sqlite3.connect('votes.db')
    cursor = conn.cursor()
    cursor.execute('''CREATE TABLE IF NOT EXISTS votes (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        username TEXT NOT NULL,
                        encrypted_vote TEXT NOT NULL,
                        encrypted_key TEXT NOT NULL,
                        hmac TEXT NOT NULL,
                        iv TEXT NOT NULL)''')
    cursor.execute('''CREATE TABLE IF NOT EXISTS users (
                        username TEXT PRIMARY KEY,
                        password TEXT NOT NULL,
                        is_admin INTEGER DEFAULT 0)''')
    conn.commit()

    # Create default admin account if it doesn't exist
    cursor.execute("SELECT * FROM users WHERE username = ?", ('admin',))
    if not cursor.fetchone():
        hashed_password = generate_password_hash('admin')
        cursor.execute("INSERT INTO users (username, password, is_admin) VALUES (?, ?, ?)", ('admin', hashed_password, 1))
        conn.commit()

    conn.close()

# Generate RSA keys for the server
private_key = rsa.generate_private_key(public_exponent=65537, key_size=2048)
public_key = private_key.public_key()

@app.route('/')
def register_page():
    return render_template('register.html')

@app.route('/login', methods=['GET', 'POST'])
def login_page():
    if request.method == 'POST':
        username = escape(request.form.get('username')).strip()
        password = request.form.get('password')

        conn = sqlite3.connect('votes.db')
        cursor = conn.cursor()
        cursor.execute("SELECT username, password, is_admin FROM users WHERE username = ?", (username,))
        user = cursor.fetchone()
        conn.close()

        if user and check_password_hash(user[1], password):
            session.clear()
            session['username'] = user[0]
            session['is_admin'] = bool(user[2])
            if session['is_admin']:
                return redirect(url_for('admin_page'))
            return redirect(url_for('vote_page'))
        else:
            return render_template('login.html', error="Nom d'utilisateur ou mot de passe incorrect")

    return render_template('login.html')

@app.route('/register', methods=['GET', 'POST'])
def register():
    if request.method == 'POST':
        username = escape(request.form.get('username')).strip()
        password = request.form.get('password')

        if not username or not password:
            return render_template('register.html', error="Veuillez remplir tous les champs")

        hashed_password = generate_password_hash(password)

        conn = sqlite3.connect('votes.db')
        cursor = conn.cursor()
        try:
            cursor.execute("INSERT INTO users (username, password) VALUES (?, ?)", (username, hashed_password))
            conn.commit()
        except sqlite3.IntegrityError:
            conn.close()
            return render_template('register.html', error="Nom d'utilisateur déjà pris")
        conn.close()
        session.clear()
        session['username'] = username
        session['is_admin'] = False
        return redirect(url_for('vote_page'))

    return render_template('register.html')

@app.route('/vote_page')
def vote_page():
    if 'username' not in session:
        return redirect(url_for('login_page'))
    return render_template('vote.html')

@app.route('/vote', methods=['POST'])
def vote():
    if 'username' not in session:
        audit_logger.warning("Unauthorized vote attempt detected.")
        return jsonify({"message": "Non autorisé. Veuillez vous connecter."}), 403

    username = session['username']

    # Check if user already voted
    conn = sqlite3.connect('votes.db')
    cursor = conn.cursor()
    cursor.execute("SELECT * FROM votes WHERE username = ?", (username,))
    if cursor.fetchone():
        audit_logger.info(f"Duplicate vote attempt detected for user: {username}")
        conn.close()
        return jsonify({"message": "Vous avez déjà voté."}), 400

    candidate = request.json.get('candidate').strip()
    if candidate:
        # Generate a unique AES key and IV
        aes_key = os.urandom(32)
        iv = os.urandom(16)
        cipher = Cipher(algorithms.AES(aes_key), modes.CBC(iv))
        encryptor = cipher.encryptor()

        # Pad the candidate data to 16 bytes
        padded_candidate = candidate.ljust(16, ' ')
        encrypted_vote = encryptor.update(padded_candidate.encode()) + encryptor.finalize()

        # Encrypt the AES key with the server's public RSA key
        encrypted_key = public_key.encrypt(
            aes_key,
            padding.OAEP(
                mgf=padding.MGF1(algorithm=hashes.SHA256()),
                algorithm=hashes.SHA256(),
                label=None
            )
        )

        # Generate HMAC for integrity verification
        hmac = HMAC(aes_key, hashes.SHA256())
        hmac.update(encrypted_vote)
        hmac_digest = hmac.finalize()

        # Store encrypted_vote, encrypted_key, IV, HMAC, and username
        cursor.execute("""
            INSERT INTO votes (username, encrypted_vote, encrypted_key, hmac, iv) 
            VALUES (?, ?, ?, ?, ?)""",
            (
                username,
                base64.b64encode(encrypted_vote).decode(),
                base64.b64encode(encrypted_key).decode(),
                base64.b64encode(hmac_digest).decode(),
                base64.b64encode(iv).decode()
            )
        )
        conn.commit()
        conn.close()

        audit_logger.info(f"Vote successfully recorded for user: {username}")
        return jsonify({"message": "Vote enregistré avec succès !"}), 200
    else:
        audit_logger.warning("Invalid candidate detected during vote submission.")
        return jsonify({"message": "Candidat invalide."}), 400

@app.route('/admin')
def admin_page():
    if 'username' not in session or not session.get('is_admin', False):
        audit_logger.warning("Unauthorized admin access attempt detected.")
        return redirect(url_for('login_page'))

    conn = sqlite3.connect('votes.db')
    cursor = conn.cursor()
    cursor.execute("SELECT encrypted_vote, encrypted_key, iv, COUNT(*) FROM votes GROUP BY encrypted_vote, encrypted_key, iv")
    results = cursor.fetchall()
    conn.close()

    decrypted_results = []
    vote_counts = {}
    for row in results:
        try:
            encrypted_vote = base64.b64decode(row[0])
            encrypted_key = base64.b64decode(row[1])
            iv = base64.b64decode(row[2])

            # Decrypt the AES key using the private RSA key
            aes_key = private_key.decrypt(
                encrypted_key,
                padding.OAEP(
                    mgf=padding.MGF1(algorithm=hashes.SHA256()),
                    algorithm=hashes.SHA256(),
                    label=None
                )
            )

            # Decrypt the vote using the AES key and IV
            cipher = Cipher(algorithms.AES(aes_key), modes.CBC(iv))
            decryptor = cipher.decryptor()
            decrypted_vote = decryptor.update(encrypted_vote) + decryptor.finalize()

            candidate_name = decrypted_vote.decode('utf-8').strip()
            decrypted_results.append((candidate_name, row[3]))
            
            if candidate_name in vote_counts:
                vote_counts[candidate_name] += 1
            else:
                vote_counts[candidate_name] = 1
        except Exception as e:
            audit_logger.error(f"Data tampering detected: {e}")
            continue

    decrypted_results = [(candidate, count) for candidate, count in vote_counts.items()]

    # Read audit logs from the log file
    try:
        with open("audit.log", "r") as log_file:
            audit_logs = log_file.readlines()
    except FileNotFoundError:
        audit_logs = ["No audit logs available."]

    audit_logger.info("Admin accessed vote results.")
    return render_template('admin.html', results=decrypted_results, audit_logs=audit_logs)

@app.route('/logout')
def logout():
    session.clear()
    return redirect(url_for('login_page'))

if __name__ == '__main__':
    init_db()
    app.run(debug=True, port=5001)
